<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NetVerse â€“ ×¦×¤×™×™×”</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/styles.css">
</head>
<body class="bg-dark text-white">
  <nav class="navbar navbar-expand-lg bg-dark navbar-dark border-bottom border-secondary">
    <div class="container-fluid">
      <a class="navbar-brand fw-bold" href="/app">ğŸ¿ NETVERSE</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#nav">
        <span class="navbar-toggler-icon"></span>
      </button>
 <div class="collapse navbar-collapse" id="nav">
        <form class="d-flex ms-auto" role="search" id="searchForm">
          <input class="form-control me-2" type="search" placeholder="×—×™×¤×•×©" aria-label="Search" id="q">
          <button class="btn btn-outline-light" type="submit">×—×¤×©</button>
        </form>
        <ul class="navbar-nav ms-3" id="authLinks">
          <li class="nav-item"><a class="nav-link" href="/login.html">×›× ×™×¡×”</a></li>
          <li class="nav-item"><a class="nav-link" href="/register.html">×”×¨×©××”</a></li>
        </ul>
      </div>
    </div>
  </nav>

  <main class="container py-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h1 class="h4 m-0">×¦×¤×™×™×”</h1>
      <a class="btn btn-outline-light" href="/app">â† ×—×–×¨×” ×œ×§×˜×œ×•×’</a>
    </div>

    <!-- ××–×•×¨ ×”× ×’×Ÿ + ×›×¤×ª×•×¨×™ ×©×œ×™×˜×” -->
    <div class="row">
      <div class="col-12">
        <video id="player" class="w-100" controls playsinline preload="metadata" poster="/img/placeholder.jpg"></video>

        <div class="d-flex justify-content-between align-items-center mt-2">
          <div>
            <div id="titleName" class="fw-bold"></div>
            <div id="titleMeta" class="small text-secondary"></div>
          </div>
          <div class="btn-group btn-group-sm" role="group" aria-label="Player controls">
            <button type="button" class="btn btn-outline-light" id="btnBack10">âª 10- ×©× '</button>
            <button type="button" class="btn btn-outline-light" id="btnForward10">10+ ×©× ' â©</button>
            <button type="button" class="btn btn-outline-light d-none" id="btnNextEp">×¤×¨×§ ×”×‘× â–¶</button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- ×¨×©×™××ª ×¤×¨×§×™× ×œ×¡×“×¨×•×ª -->
    <div class="row mt-4" id="episodesRow" style="display:none;">
      <div class="col-12 col-md-8">
        <h2 class="h6 mb-2">
          ×¤×¨×§×™× ×‘×¡×“×¨×”:
          <span id="seriesName"></span>
        </h2>
        <div id="episodesList" class="list-group list-group-flush"></div>
      </div>
    </div>
  </main>
 <script>
    // ×¤×•×¨× ××˜ ×–××Ÿ
    function formatTime(sec) {
      sec = Math.max(0, Math.floor(Number(sec) || 0));
      const h = Math.floor(sec / 3600);
      const m = Math.floor((sec % 3600) / 60);
      const s = sec % 60;
      const pad = (n) => n.toString().padStart(2, '0');
      if (h > 0) return `${h}:${pad(m)}:${pad(s)}`;
      return `${m}:${pad(s)}`;
    }

    // ×˜×¢×™× ×ª ×›×•×ª×¨×ª ×¡×¨×˜×•×Ÿ ×•×¨×©×™××ª ×¤×¨×§×™×
    (async function () {
      const qs = new URLSearchParams(location.search);
      const id = qs.get('id');
      if (!id) {
        alert('×—×¡×¨ ××–×”×” ×›×•×ª×¨');
        location.href = '/app';
        return;
      }

      let currentTitle = null;
      const videoEl = document.getElementById('player');

      try {
        const r = await fetch('/api/titles/' + encodeURIComponent(id), {
          credentials: 'same-origin',
          cache: 'no-store'
        });
        if (!r.ok) throw new Error('×œ× × ××¦× ×›×•×ª×¨');
        const payload = await r.json();
        const t = payload && payload.title;
        if (!t) throw new Error('×œ× × ××¦× ×›×•×ª×¨');
        currentTitle = t;
        
        document.getElementById('titleName').textContent = t.name || '';
        const metaParts = [];
        if (t.year) metaParts.push(t.year);
        if (Array.isArray(t.genres) && t.genres.length) {
          metaParts.push(t.genres.join(', '));
        }
        document.getElementById('titleMeta').textContent = metaParts.join(' â€¢ ');

        const url = t.videoPath || (t.videoFileId ? ('/media/' + t.videoFileId) : '');
        if (!url) {
          alert('××™×Ÿ ×§×•×‘×¥ ×•×™×“××• ××©×•×™×š ×œ×›×•×ª×¨×ª');
          return;
        }

        videoEl.src = url;

        // ×”×ª×—×œ×” ××”×–××Ÿ (t=) ×× ×”×’×™×¢×• ××”××©×š ×¦×¤×™×™×”
        const startAt = Number(qs.get('t') || 0);
        videoEl.addEventListener('loadedmetadata', () => {
          try {
            if (startAt > 0) videoEl.currentTime = startAt;
          } catch (e) {}
        });

        // ×›×¤×ª×•×¨×™ 10 ×©× ×™×•×ª ×§×“×™××”/××—×•×¨×”
        document.getElementById('btnBack10').addEventListener('click', () => {
          if (!videoEl) return;
          try {
            videoEl.currentTime = Math.max(0, (videoEl.currentTime || 0) - 10);
          } catch (e) {}
        });
        document.getElementById('btnForward10').addEventListener('click', () => {
          if (!videoEl) return;
          try {
            const dur = Number.isFinite(videoEl.duration) ? videoEl.duration : (videoEl.currentTime || 0) + 10;
            videoEl.currentTime = Math.min(dur, (videoEl.currentTime || 0) + 10);
          } catch (e) {}
        });

        // ×˜×¢×™× ×ª ×¨×©×™××ª ×¤×¨×§×™× ×× ×–×” ×¡×“×¨×”
        await loadEpisodesForSeries(currentTitle);

      } catch (e) {
        console.error(e);
        alert('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×›×•×ª×¨×ª ×œ×¦×¤×™×™×”');
        location.href = '/app';
      }
    })();
   
    // ×˜×¢×™× ×ª ×›×œ ×”×¤×¨×§×™× ×©×œ ×”×¡×“×¨×” + ××™× ×“×™×§×¦×™×™×ª ×”×ª×§×“××•×ª + ×›×¤×ª×•×¨ "×¤×¨×§ ×”×‘×"
    async function loadEpisodesForSeries(currentTitle) {
      if (!currentTitle) return;

      const kind = String(currentTitle.kind || '').toLowerCase();
      if (kind !== 'series') {
        // ×œ× ×¡×“×¨×” â€“ ××™×Ÿ ×¨×©×™××ª ×¤×¨×§×™×
        return;
      }

      const fullName = String(currentTitle.name || '');
      const baseName = fullName.split('-')[0].trim(); // ×—×œ×§ ×œ×¤× ×™ ×”Ö¾"-"
      if (!baseName) return;

      const episodesRow = document.getElementById('episodesRow');
      const episodesList = document.getElementById('episodesList');
      const seriesNameEl = document.getElementById('seriesName');
      const btnNextEp = document.getElementById('btnNextEp');

      seriesNameEl.textContent = baseName;

      try {
        // 1) ××‘×™××™× ××ª ×›×œ ×”×˜×™×™×˜×œ×™× ×©××›×™×œ×™× ××ª ×©× ×”×¡×“×¨×”
        const rTitles = await fetch('/api/titles?q=' + encodeURIComponent(baseName), {
          credentials: 'same-origin',
          cache: 'no-store'
        });
        if (!rTitles.ok) throw new Error('failed titles');
        const dataTitles = await rTitles.json();
        let episodes = Array.isArray(dataTitles.titles) ? dataTitles.titles : [];

        // ××¡× × ×™× ×¨×§ kind=series ×•×©×× ××ª×—×™×œ ×‘×©× ×”×¡×“×¨×”
        episodes = episodes.filter(ep =>
          String(ep.kind || '').toLowerCase() === 'series' &&
          String(ep.name || '').startsWith(baseName)
        );

        if (!episodes.length) return;

        // 2) ×××¤×™× ××¡×¤×¨ ×¤×¨×§ ××ª×•×š ×”×©× (×”××¡×¤×¨ ×”×¨××©×•×Ÿ ×‘-string)
        episodes = episodes.map(ep => {
          const m = String(ep.name || '').match(/(\d+)/);
          const epNum = m ? parseInt(m[1], 10) || 0 : 0;
          return { ...ep, _epNum: epNum };
        }).sort((a, b) => {
          if (a._epNum !== b._epNum) return a._epNum - b._epNum;
          return String(a.name || '').localeCompare(String(b.name || ''), 'he');
        });

        // 3) ××‘×™××™× ×”×™×¡×˜×•×¨×™×™×ª ×¦×¤×™×™×” ×œ×›×œ ×”×˜×™×™×˜×œ×™× ×©×œ ×”×¤×¨×•×¤×™×œ
        const watchedMap = new Map();
        try {
          const rWatch = await fetch('/api/watch', {
            credentials: 'same-origin',
            cache: 'no-store'
          });
          if (rWatch.ok) {
            const dataWatch = await rWatch.json();
            for (const item of (dataWatch.items || [])) {
              watchedMap.set(String(item.titleId), item);
            }
          }
        } catch (e) {
          console.warn('watch history fetch failed', e);
        }

        // ×—×™×©×•×‘ ×”×¤×¨×§ ×”×‘×
        episodesList.innerHTML = '';
        const currentIdStr = String(currentTitle._id);
        const currentIdx = episodes.findIndex(ep => String(ep._id) === currentIdStr);
        let nextEpisodeId = null;
        if (currentIdx >= 0 && currentIdx < episodes.length - 1) {
          nextEpisodeId = episodes[currentIdx + 1]._id;
        }

        episodes.forEach((ep, idx) => {
          const idStr = String(ep._id);
          const wh = watchedMap.get(idStr);
          const positionSec = wh?.positionSec || 0;
          const completed = !!wh?.completed;
          const durationSec = ep.durationSec || ep.runtimeSec || 0;

          const progress = durationSec
            ? Math.min(100, Math.round((positionSec / durationSec) * 100))
            : (positionSec ? 40 : 0);

          const isCurrent = (idStr === currentIdStr);

          const labelEpNum = ep._epNum ? `×¤×¨×§ ${ep._epNum}` : `×¤×¨×§ ${idx + 1}`;
          // ×”×—×œ×§ ××—×¨×™ ×©× ×”×¡×“×¨×”
          let restName = String(ep.name || '').slice(baseName.length).trim();
          if (restName.startsWith('-')) restName = restName.slice(1).trim();
          const rowTitle = restName ? `${labelEpNum} Â· ${restName}` : labelEpNum;

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className =
            'list-group-item list-group-item-action d-flex flex-column align-items-start ' +
            'bg-dark text-white border-secondary' +
            (isCurrent ? ' active' : '');
          btn.dataset.id = idStr;

          btn.innerHTML = `
            <div class="d-flex w-100 justify-content-between">
              <div>${rowTitle}</div>
              ${isCurrent ? '<span class="badge bg-light text-dark ms-2">×× ×•×’×Ÿ ×¢×›×©×™×•</span>' : ''}
            </div>
            ${
              (positionSec || completed)
                ? `
                  <div class="w-100 mt-1">
                    <div class="progress-xs"><div style="width:${completed ? 100 : progress}%;"></div></div>
                    <div class="small text-secondary mt-1">
                      ${completed ? '× ×¦×¤×” ×¢×“ ×”×¡×•×£' : '×”××©×š ×-' + formatTime(positionSec)}
                    </div>
                  </div>
                `
                : ''
            }
          `;

          btn.addEventListener('click', () => {
            const start = wh?.positionSec || 0;
            const tParam = start ? `&t=${Math.floor(start)}` : '';
            location.href = `/watch.html?id=${encodeURIComponent(idStr)}${tParam}`;
          });

          episodesList.appendChild(btn);
        });

        // ××¦×™×’×™× ××ª ××–×•×¨ ×”×¤×¨×§×™× ×¨×§ ×× ×™×© ×™×•×ª×¨ ××¤×¨×§ ××—×“
        if (episodes.length > 1) {
          episodesRow.style.display = '';
        }

        // ×›×¤×ª×•×¨ "×¤×¨×§ ×”×‘×"
        if (nextEpisodeId) {
          btnNextEp.classList.remove('d-none');
          btnNextEp.onclick = () => {
            const whNext = watchedMap.get(String(nextEpisodeId));
            const start = whNext?.positionSec || 0;
            const tParam = start ? `&t=${Math.floor(start)}` : '';
            location.href = `/watch.html?id=${encodeURIComponent(nextEpisodeId)}${tParam}`;
          };
        }
      } catch (e) {
        console.error('failed episodes list', e);
      }
    }
  </script>

  <!-- ×—×©×•×‘: watch.js ×©××‘×¦×¢ saveProgress -->
  <script src="/js/watch.js?v=3"></script>
</body>
</html>





